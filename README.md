# const-string

This is a constant string library - a library to process string literals in
compile-time.

Processing string literal in compile time is useful in conjunction with the
preprocessor stringification mechanism `#`. The mechanism allows you to create
literals from macro parameters, thus converting usually predefined macros or
enums into string. This is partly useful, but sometimes you might need
substring of that.

For example, let's say you are programming logger for OpenGL debug messages.
This is done by calling:
```cpp
glEnable(GL_DEBUG_OUTPUT);
glDebugMessageCallback(onDebugMessage, /* userdata */nullptr);
```
with callback looks like this:
```cpp
void GLAPIENTRY displayErrors(
        GLenum source,
        GLenum type,
        GLuint id,
        GLenum severity,
        GLsizei length,
        const GLchar *message,
        const void *userParam
    ) {
    /* Print the message to stdout/stderr here */
}
```
but the problem here is that `source`, `type` and `severity` are just
`unsigned int`. When comparing them in code it does make sense:
```cpp
if(severity == GL_DEBUG_SEVERITY_HIGH) {...}
```
but if printed this will just print some number. We can create a function that
switches from all severities and retrieve a name:
```cpp
const char *glGetDebugSeverity(GLenum value) {
    switch(value) {
        case GL_DEBUG_SEVERITY_HIGH: return "HIGH";
        /* other severities here ... */
        default: return "":
    }
}
```
but this would require manually associating a string with each severity. A
better way would be to use preprocessor to do it for us.

```cpp
const char *glGetDebugSeverity(GLenum value) {
    switch(value) {
#define MAKE_CASE(val) case val: return #val
        MAKE_CASE(GL_DEBUG_SEVERITY_HIGH);
        /* other severities here ... */
#undef MAKE_CASE
        default: return "":
    }
}
```
There is no repetition! However, the return string contains the whole
preprocessor name `GL_DEBUG_SEVERITY_HIGH`. This is where `const_string` comes
to help. We can cut off part of the string in compile-time, without affecting
the runtime at all.
```cpp
const char *glGetDebugSeverity(GLenum value) {
    using literal::operator""_string;
    constexpr auto prefix_length = "GL_DEBUG_SEVERITY_"_string.length();
    switch(value) {
#define MAKE_CASE(val) case val: return #val##_string.after<prefix_length>().value();
        MAKE_CASE(GL_DEBUG_SEVERITY_HIGH);
        /* other severities here ... */
#undef MAKE_CASE
        default: return "":
    }
}
```
Because all calls are `constexpr`, this will create an equivalent ot the
function above. It will return the string `"HIGH"` for
`GL_DEBUG_SEVERITY_HIGH`, but it will evaluate the code at compile-time,
therefore the run-time performance will be equivalent to specifying
string literal `"HIGH"` directly.

Note: The above applies to optimized code (usually `-O2` or `-O3`). In
`-O0` this will still be literal string, but it will result in calling to some
no-op functions.

## Operations

Currently the following operations are available:

* ``string::length()`` - returns the number of characters (bytes) in the string;
* ``string::concat()`` - returns a concatenation of the current `string` and the provided `string`.
* ``string::before()`` - returns a string containing all characters of the current string before certain index.
* ``string::after()`` - returns a string containing all characters of the current string after certain index.
* ``string::substr()`` - returns a substring containing exactly `length` characters starting at `start`.
* ``string::substring()`` - returns a substring containing all characters between two indices.
* Operators `>`, `>=`, `<`, `<=`, `==`, `!=` - returns `true` or `false` is the string byte sequence follows, precedes or is equal to the another byte sequence.

To construct a string, the user-define literal of C++20 is used, and available under `literal` namespace.
In order to avoid namespace pollution, you can use `using` syntax to import the operator wherever is required.

The ``string`` contains implicit operator `const char *`, which will automatically convert the string sequence to literal string when used to appropriate function.
When used in conjunction with out, to avoid `static_cast`, the equivalent `value()` operation can be used.

## Caveats

### C++ name mangling
The literal string is represented by a template of characters. For example, the string `"Hello!"` will result in type:
```cpp
literal::string<'H', 'e', 'l', 'l', 'o', '!'>;
```
This can produce some very long mangled names in some compilers. To avoid such names, be sure to strip any private symbol using this type.

Some programs (like `CLion`) tend to attempt to process template generated by this expressions. While the generated templates are simple,
the amount template arguments deduction and `auto` can really slow down such processes to the point the IDE becomes unusable.
No discernible difference in compile time is detected, although this might increase the compile time for some large projects (but it will not affect the run-time performance).

### Clang-Tidy suggestions
Because the string computation is in compile time, some programs like `clang-tidy` might report
some `literal::string` comparison as `always true` and `always false`, allowing you to simplify it.
This would be correct outside preprocessor, but you might want to ignore this in preprocessor.
For example:
```cpp
auto s1 = "Hello!"_string;
auto s2 = "Hello!"_string;
auto s3 = "Hi!"_string;
auto t1 = s1 == s2 ? "true" : "false";
auto t2 = s1 == s3 ? "true" : "false";
```
will be equivalent to the following code after optimization:
```cpp
auto t1 = "true";
auto t2 = "false";
```

### UTF-8 strings

The literal string operate on template of `char`. While it can encode UTF-8 strings, that will
always represent bytes instead of characters. This could potentially lead to some invalid UTF-8
sequences, if for example `before<N>` or `after<N>` is used with index that cuts off multibyte
sequence. This should be only a problem for hard-coded indices. To cut a string based on index,
compute the index by using the length of the hardcoded UTF-8 substring to avoid invalid indices.


### Compile-time assertions

Substring operations use `size_t` on input. Those indices are used as template parameters, so
invalid indices can easily crash some compilers. For example, if `start` is `0` and `length` is 5,
`substr` might generate `0 - 5 = 18446744073709551611` which is definitely invalid index, but
it might result in out-of-memory operation in the compiler, if not prevented. GCC has upper limits
for the number of template parameters, so it will give you an error, but other compilers might
just eat your memory. To prevent that we have `static_assert` that will yield sensible error
message is indices are invalid.

As a result, you cannot compile code whose indices are not valid. For example:
```cpp
"My name is John"_string.substring<2, 9>(); // valid, yields "name is";
"My name is John"_string.substring<9, 2>(); // invalid, compile error;
"My name is John"_string.after<"My name is "_string.length()>(); // preferred, compiled to "John" literal
```

## Work in progress

It is unclear whether C++20 allows such complex programming of the compiler, but if possible,
we plan to process simple patterns like:

```cpp
"This must print ${0} some values contained in ${1}\n";
```
resulting in separate literals ``"This must print "`` and ``" some values contained in "``,
which then together a tuple, can result into ``printf`` like function, but in C++ style.

The current C++ syntax for printing is terrible, requiring you to separate strings with
the shift operator `<<`, and include manipulators in there. In contrast `printf` syntax
is cleaner, but due to `va_args` it might be insecure. Most compilers warns about
mismatched types, but you must match the types manually.

The idea is to have a function that accept a string literal, process it in compile-time,
resulting in appropriate functions. Let's say we have:

```cpp
literal::print("Expected ${1} < ${0}, but got ${1} > ${0}\n"_string, range_max, range_min);
```

The following advantages can be observed:

* The syntax is almost as clean as `printf`.
* The arguments can be printed multiple times in the same string.
* How the arguments are printed is based on template argument deduction. In case of manipulators,
the caller might wrap the argument in some manipulator type.

The code is processing in compile time, resulting in the following expanded code:
```cpp
stream << "Expected " << range_min << " < " << range_max << ", but got " << range_min << " > " << range_max << "\n";
```